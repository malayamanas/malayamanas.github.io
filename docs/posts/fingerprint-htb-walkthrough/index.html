<!doctype html><html lang=en><head><title>Fingerprint HTB - Insane Linux Box Walkthrough :: VAPT Walkthroughs</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Complete walkthrough of Fingerprint HTB machine featuring XSS, LFI, HQL injection, Java deserialization, JWT forging, SetUID binary exploitation, and ECB crypto attacks"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://malayamanas.github.io/posts/fingerprint-htb-walkthrough/><link rel=stylesheet href=https://malayamanas.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://malayamanas.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://malayamanas.github.io/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://malayamanas.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://malayamanas.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://malayamanas.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://malayamanas.github.io/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://malayamanas.github.io/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://malayamanas.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://malayamanas.github.io/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://malayamanas.github.io/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://malayamanas.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://malayamanas.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://malayamanas.github.io/terminal.css><link rel="shortcut icon" href=https://malayamanas.github.io/favicon.png><link rel=apple-touch-icon href=https://malayamanas.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Fingerprint HTB - Insane Linux Box Walkthrough"><meta property="og:description" content="Complete walkthrough of Fingerprint HTB machine featuring XSS, LFI, HQL injection, Java deserialization, JWT forging, SetUID binary exploitation, and ECB crypto attacks"><meta property="og:url" content="https://malayamanas.github.io/posts/fingerprint-htb-walkthrough/"><meta property="og:site_name" content="VAPT Walkthroughs"><meta property="og:image" content="https://malayamanas.github.io/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="HTB"><meta property="article:section" content="Linux"><meta property="article:published_time" content="2025-09-22 08:00:00 +0000 UTC"></head><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a href=https://malayamanas.github.io/><div class=logo>Terminal</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;â–¾</li><li><ul class=menu__dropdown><li><a href=/>Home</a></li><li><a href=/search>Search</a></li><li><a href=/tags>Tags</a></li><li><a href=/difficulty>Difficulty</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/>Home</a></li><li><a href=/search>Search</a></li><li><a href=/tags>Tags</a></li><li><a href=/difficulty>Difficulty</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://malayamanas.github.io/posts/fingerprint-htb-walkthrough/>Fingerprint HTB - Insane Linux Box Walkthrough</a></h1><div class=post-meta><time class=post-date>2025-09-22</time></div><span class=post-tags>#<a href=https://malayamanas.github.io/tags/insane-linux/>insane-linux</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/web/>web</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/xss/>xss</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/lfi/>lfi</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/hql-injection/>hql-injection</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/deserialization/>deserialization</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/jwt-forging/>jwt-forging</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/setuid-binary/>setuid-binary</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/ecb-crypto/>ecb-crypto</a>&nbsp;
#<a href=https://malayamanas.github.io/tags/privilege-escalation/>privilege-escalation</a>&nbsp;</span><div class=post-content><div><h1 id=fingerprint-htb---insane-linux-box-walkthrough>Fingerprint HTB - Insane Linux Box Walkthrough<a href=#fingerprint-htb---insane-linux-box-walkthrough class=hanchor arialabel=Anchor>#</a></h1><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/YBabDbyk3eo?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>Below is a chronological summary of the key exploitation steps and techniques used in the &ldquo;Fingerprint&rdquo; machine from Hack The Box, as described in the provided data:</p><ol><li><p><strong>Initial Reconnaissance with Nmap</strong>:</p><ul><li>Technique: Network scanning using <code>nmap -sC -sV -oA fingerprint &lt;IP></code>.</li><li>Findings: Identified open ports: SSH (22), HTTP (80, running Werkzeug on Python 2), and HTTP (8080, running Sun GlassFish 5.0.1, Java-based). Noted outdated software versions (Python 2, GlassFish ~2017-2018).</li></ul></li><li><p><strong>Web Enumeration</strong>:</p><ul><li>Technique: Manual browsing and directory enumeration using <code>feroxbuster -u &lt;URL> -B</code> and <code>wfuzz</code> to discover backups and potential vulnerabilities.</li><li>Findings: Port 80 hosts a login panel (&ldquo;My Log&rdquo;) with a 2019 copyright, indicating Flask (Python 2). Port 8080 has a login form with a 2018 copyright. Discovered an Execute-After-Redirect (EAR) vulnerability on <code>/admin</code> (302 redirect with unusual response size, revealing <code>auth.log</code>).</li></ul></li><li><p><strong>Cross-Site Scripting (XSS) Testing</strong>:</p><ul><li>Technique: Tested login form on port 8080 for XSS by injecting <code>&lt;b>ipsec&lt;/b></code> and <code>&lt;img src=http://&lt;attacker-ip>/image></code>.</li><li>Outcome: Confirmed XSS vulnerability as user input was reflected unfiltered, and an external request was triggered to the attacker&rsquo;s server, indicating potential for cookie theft.</li></ul></li><li><p><strong>Local File Inclusion (LFI) Exploitation</strong>:</p><ul><li>Technique: Tested directory traversal in the log viewing functionality (e.g., <code>../../etc/passwd</code>).</li><li>Outcome: Successfully accessed <code>/etc/passwd</code>, <code>/proc/self/cmdline</code> (revealing Flask on port 80), and Python source files (<code>app.py</code>, <code>auth.py</code>, <code>util.py</code>) via LFI, confirming Flask application and revealing a secret key for JWT forging.</li></ul></li><li><p><strong>HQL Injection</strong>:</p><ul><li>Technique: Tested login form on port 8080 for HQL injection (similar to SQL injection but for Hibernate). Used payloads like <code>admin' OR '1'='1</code> and <code>substring(username,1,1)='m'</code>.</li><li>Outcome: Confirmed HQL injection by triggering Hibernate errors and extracting data (e.g., usernames <code>admin</code> and <code>michael</code>). Retrieved a JWT token containing a Java serialized object (base64-encoded).</li></ul></li><li><p><strong>JWT Forging and Deserialization Vulnerability</strong>:</p><ul><li>Technique: Used the secret key from LFI to forge a JWT with a manipulated payload. Crafted a custom Java serialized object to exploit a deserialization vulnerability in the GlassFish application.</li><li>Steps:<ul><li>Downloaded Java source files (<code>User.java</code>, <code>Profile.java</code>, <code>UserProfileStorage.java</code>) from <code>/backups</code>.</li><li>Identified a command injection vulnerability in <code>UserProfileStorage.java</code> where an admin profile triggers a shell command with the username.</li><li>Created a Java project in Eclipse to generate a serialized object (<code>ipsec.ser</code>) with <code>adminProfile=true</code>.</li><li>Uploaded <code>ipsec.ser</code> to <code>/data/uploads</code> via the application&rsquo;s upload functionality.</li><li>Forged a JWT with a username containing a directory traversal payload (<code>../../data/uploads/ipsec.ser</code>) to load the malicious serialized object.</li></ul></li><li>Outcome: Achieved command execution by triggering a ping to the attacker&rsquo;s machine, later upgraded to a reverse shell (<code>/dev/tcp/&lt;attacker-ip>/9000</code>).</li></ul></li><li><p><strong>SetUID Binary Exploitation</strong>:</p><ul><li>Technique: Identified a SetUID binary (<code>/usr/bin/cmatch</code>) owned by user <code>john</code> using <code>find / -perm -4000</code>.</li><li>Analysis: <code>cmatch</code> counts matches of a pattern in a file (e.g., <code>cmatch /etc/passwd root</code> returned 3 matches). Supported regex, allowing boolean-based file content exfiltration.</li><li>Exploitation: Wrote a Python script to brute-force the contents of <code>/home/john/.ssh/id_rsa</code> one character at a time using regex patterns, leveraging <code>cmatch</code>&rsquo;s SetUID privileges.</li><li>Outcome: Extracted John&rsquo;s SSH private key.</li></ul></li><li><p><strong>SSH Key Cracking</strong>:</p><ul><li>Technique: Used <code>john</code> to crack the passphrase of the SSH key with a wordlist and passwords from the system (e.g., Hibernate database password <code>q9...</code>).</li><li>Outcome: Successfully cracked the passphrase, allowing SSH login as user <code>john</code>.</li></ul></li><li><p><strong>Further Enumeration as John</strong>:</p><ul><li>Technique: Searched for files owned by <code>john</code> using <code>find / -user john</code>. Identified a zip file (<code>/var/backups/flask_app_secure.back</code>).</li><li>Outcome: Copied and unzipped the file, revealing a Flask application (<code>app.py</code>, <code>auth.py</code>) with custom crypto in ECB mode.</li></ul></li><li><p><strong>ECB Mode Crypto Exploitation</strong>:</p><ul><li>Technique: Analyzed <code>app.py</code> and identified ECB mode encryption (block size 16 bytes) for cookies in the format <code>username,secret,true/false</code>. Exploited ECB&rsquo;s property where identical plaintext blocks produce identical ciphertext blocks.</li><li>Steps:<ul><li>Used XSS to steal a cookie from the Flask app (port 8088, discovered via <code>ss -lntp</code> and <code>flaskbeta.service</code>).</li><li>Created an SSH tunnel (<code>ssh -L 8088:localhost:8088</code>) to access the app locally.</li><li>Wrote a Python script to brute-force the secret one byte at a time by padding usernames (e.g., 15 A&rsquo;s + guess) and matching ciphertext blocks.</li><li>Crafted a cookie with <code>admin,secret,true</code> to gain admin access.</li></ul></li><li>Outcome: Accessed <code>/admin</code> on port 8088, revealing another LFI vulnerability.</li></ul></li><li><p><strong>Root LFI and Privilege Escalation</strong>:</p><ul><li>Technique: Used the admin LFI on port 8088 to read <code>/root/.ssh/id_rsa</code>.</li><li>Outcome: Extracted the root SSH private key, used it to SSH as <code>root</code>, and achieved full system compromise.</li></ul></li></ol><h3 id=summary-of-techniques>Summary of Techniques:<a href=#summary-of-techniques class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Reconnaissance</strong>: Nmap, Feroxbuster, Wfuzz.</li><li><strong>Web Vulnerabilities</strong>: XSS, LFI, HQL injection.</li><li><strong>Deserialization</strong>: Custom Java serialized object crafting for command injection.</li><li><strong>Binary Exploitation</strong>: SetUID binary (<code>cmatch</code>) for file content exfiltration.</li><li><strong>Crypto Exploitation</strong>: ECB mode brute-forcing for admin cookie forging.</li><li><strong>Privilege Escalation</strong>: LFI to extract SSH keys, passphrase cracking with <code>john</code>.</li></ul><p>This sequence reflects the chronological order of exploitation steps, leveraging multiple vulnerabilities to escalate from unauthenticated access to root privileges.</p><p>List all the gaps in each service or systems, that can be fixed with either proper source code fix or configuration fix. Below is a detailed list of the vulnerabilities (gaps) identified in the services and systems of the &ldquo;Fingerprint&rdquo; machine from Hack The Box, as described in the provided data. For each vulnerability, I provide a description of the gap and recommend fixes, specifying whether they involve source code changes or configuration adjustments. The fixes are designed to address the root causes of the vulnerabilities and prevent exploitation.</p><hr><h3 id=1-execute-after-redirect-ear-vulnerability-in-flask-application-port-80>1. <strong>Execute-After-Redirect (EAR) Vulnerability in Flask Application (Port 80)</strong><a href=#1-execute-after-redirect-ear-vulnerability-in-flask-application-port-80 class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Gap Description</strong>: The <code>/admin</code> endpoint in the Flask application returns a 302 redirect but includes sensitive content (e.g., <code>auth.log</code>) in the response body, which can be intercepted by modifying the HTTP response in a tool like Burp Suite. This is due to the Flask application generating a response with <code>make_response(site_content)</code> before setting the redirect header.</li><li><strong>Impact</strong>: Attackers can access sensitive data (e.g., log file paths) by intercepting the response, bypassing the intended redirect.</li><li><strong>Fix</strong>:<ul><li><strong>Source Code Fix</strong>:<ul><li>Modify the <code>/admin</code> endpoint to avoid including sensitive content in the response body before redirecting. Instead of <code>make_response(site_content)</code>, use a direct redirect without rendering content:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>return</span> redirect(<span style=color:#e6db74>&#39;/login&#39;</span>, code<span style=color:#f92672>=</span><span style=color:#ae81ff>302</span>)
</span></span></code></pre></div></li><li>Ensure no sensitive data is included in the response unless explicitly required.</li></ul></li><li><strong>Configuration Fix</strong>:<ul><li>None directly applicable, as this is primarily a coding issue. However, ensure that web servers (e.g., Werkzeug) are configured to enforce strict HTTP response handling and log any anomalies for review.</li></ul></li></ul></li><li><strong>Additional Best Practice</strong>:<ul><li>Implement Content Security Policy (CSP) headers to prevent unintended data exposure in case of misconfigured redirects.</li><li>Regularly audit endpoints for unexpected response content using automated tools.</li></ul></li></ul><hr><h3 id=2-cross-site-scripting-xss-in-login-form-port-8080-glassfish>2. <strong>Cross-Site Scripting (XSS) in Login Form (Port 8080, GlassFish)</strong><a href=#2-cross-site-scripting-xss-in-login-form-port-8080-glassfish class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Gap Description</strong>: The login form on port 8080 does not sanitize user input, allowing reflected XSS via payloads like <code>&lt;b>ipsec&lt;/b></code> or <code>&lt;img src=http://&lt;attacker-ip>/image></code>. This enables attackers to steal cookies or browser fingerprints.</li><li><strong>Impact</strong>: Attackers can execute malicious JavaScript in the context of the victim&rsquo;s browser, potentially stealing session cookies or other sensitive data.</li><li><strong>Fix</strong>:<ul><li><strong>Source Code Fix</strong>:<ul><li>Sanitize all user inputs in the login form before rendering them. Use a library like Apache Commons Text or OWASP Java Encoder to escape HTML, JavaScript, and other special characters:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> org.owasp.encoder.Encode;
</span></span><span style=display:flex><span>String sanitizedInput <span style=color:#f92672>=</span> Encode.<span style=color:#a6e22e>forHtml</span>(username);
</span></span></code></pre></div></li><li>Alternatively, use a template engine with built-in escaping (e.g., JSP with JSTL) to ensure outputs are properly encoded.</li></ul></li><li><strong>Configuration Fix</strong>:<ul><li>Enable a strict Content Security Policy (CSP) to restrict script sources:<pre tabindex=0><code>Content-Security-Policy: script-src &#39;self&#39;; object-src &#39;none&#39;;
</code></pre></li><li>Configure the server to set the <code>X-XSS-Protection: 1; mode=block</code> header to enable browser XSS filtering (though modern browsers rely more on CSP).</li></ul></li></ul></li><li><strong>Additional Best Practice</strong>:<ul><li>Validate input on the server side using allowlists for expected characters.</li><li>Regularly test for XSS vulnerabilities using tools like OWASP ZAP or Burp Suite.</li></ul></li></ul><hr><h3 id=3-local-file-inclusion-lfi-in-flask-application-port-80>3. <strong>Local File Inclusion (LFI) in Flask Application (Port 80)</strong><a href=#3-local-file-inclusion-lfi-in-flask-application-port-80 class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Gap Description</strong>: The log viewing functionality allows directory traversal (e.g., <code>../../etc/passwd</code>), enabling attackers to read sensitive files like <code>/etc/passwd</code>, <code>/proc/self/cmdline</code>, and Python source code (<code>app.py</code>, <code>auth.py</code>, <code>util.py</code>). The application fails to sanitize or restrict file paths.</li><li><strong>Impact</strong>: Attackers can access sensitive system files and source code, exposing configuration details, secret keys, and other critical information.</li><li><strong>Fix</strong>:<ul><li><strong>Source Code Fix</strong>:<ul><li>Implement strict path validation to ensure only authorized files can be accessed. Use a whitelist of allowed file names and restrict access to a specific directory:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span>ALLOWED_FILES <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;auth.log&#39;</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>view_log</span>(filename):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> filename <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> ALLOWED_FILES:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Invalid file&#34;</span>, <span style=color:#ae81ff>403</span>
</span></span><span style=display:flex><span>    safe_path <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(<span style=color:#e6db74>&#39;/var/log/app&#39;</span>, filename)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>realpath(safe_path)<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#39;/var/log/app&#39;</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Access denied&#34;</span>, <span style=color:#ae81ff>403</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Proceed with file reading</span>
</span></span></code></pre></div></li><li>Avoid using user input directly in file paths without normalization and validation.</li></ul></li><li><strong>Configuration Fix</strong>:<ul><li>Restrict file system permissions to ensure the Flask application runs with minimal privileges (e.g., non-root user with access only to necessary directories).</li><li>Configure the web server (e.g., Werkzeug or a reverse proxy like Nginx) to block requests with suspicious characters like <code>../</code> using URL filtering rules.</li></ul></li></ul></li><li><strong>Additional Best Practice</strong>:<ul><li>Use a Web Application Firewall (WAF) to detect and block directory traversal attempts.</li><li>Regularly audit file access logs to identify unauthorized access attempts.</li></ul></li></ul><hr><h3 id=4-hql-injection-in-glassfish-application-port-8080>4. <strong>HQL Injection in GlassFish Application (Port 8080)</strong><a href=#4-hql-injection-in-glassfish-application-port-8080 class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Gap Description</strong>: The login form on port 8080 is vulnerable to HQL injection due to unsanitized user input in Hibernate queries. Payloads like <code>admin' OR '1'='1</code> or <code>substring(username,1,1)='m'</code> allow attackers to extract database information (e.g., usernames, fingerprints) and bypass authentication.</li><li><strong>Impact</strong>: Attackers can extract sensitive data from the database or authenticate as arbitrary users, obtaining JWT tokens.</li><li><strong>Fix</strong>:<ul><li><strong>Source Code Fix</strong>:<ul><li>Use parameterized queries (Prepared Statements) in Hibernate to prevent injection:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Query query <span style=color:#f92672>=</span> session.<span style=color:#a6e22e>createQuery</span>(<span style=color:#e6db74>&#34;FROM User WHERE username = :username&#34;</span>);
</span></span><span style=display:flex><span>query.<span style=color:#a6e22e>setParameter</span>(<span style=color:#e6db74>&#34;username&#34;</span>, username);
</span></span></code></pre></div></li><li>Avoid concatenating user input directly into HQL queries.</li></ul></li><li><strong>Configuration Fix</strong>:<ul><li>Configure Hibernate to use strict query validation and logging to detect malformed queries.</li><li>Limit database permissions to the application user, restricting access to only necessary tables and operations (e.g., SELECT-only for authentication queries).</li></ul></li></ul></li><li><strong>Additional Best Practice</strong>:<ul><li>Implement input validation to reject unexpected characters (e.g., quotes, SQL/HQL keywords).</li><li>Use an ORM configuration that enforces type safety and restricts query capabilities to prevent advanced exploits like boolean-based blind injections.</li></ul></li></ul><hr><h3 id=5-java-deserialization-vulnerability-in-glassfish-application-port-8080>5. <strong>Java Deserialization Vulnerability in GlassFish Application (Port 8080)</strong><a href=#5-java-deserialization-vulnerability-in-glassfish-application-port-8080 class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Gap Description</strong>: The application processes a JWT token containing a base64-encoded Java serialized object, which is deserialized without validation. The <code>UserProfileStorage.java</code> class executes a shell command if <code>adminProfile=true</code>, and the <code>username</code> field is used unsanitized, allowing command injection via a crafted serialized object.</li><li><strong>Impact</strong>: Attackers can achieve arbitrary command execution by uploading a malicious serialized object and forging a JWT to trigger it.</li><li><strong>Fix</strong>:<ul><li><strong>Source Code Fix</strong>:<ul><li>Avoid deserialization of untrusted input. If deserialization is necessary, use a strict allowlist of expected classes:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.io.ObjectInputFilter;
</span></span><span style=display:flex><span>ObjectInputFilter filter <span style=color:#f92672>=</span> ObjectInputFilter.<span style=color:#a6e22e>Config</span>.<span style=color:#a6e22e>createFilter</span>(<span style=color:#e6db74>&#34;com.admin.security.source.User;!*&#34;</span>);
</span></span><span style=display:flex><span>ObjectInputStream ois <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectInputStream(inputStream);
</span></span><span style=display:flex><span>ois.<span style=color:#a6e22e>setObjectInputFilter</span>(filter);
</span></span></code></pre></div></li><li>Remove the command execution logic from <code>UserProfileStorage.java</code>. Replace it with a safer mechanism (e.g., database-driven authorization):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span> (profile.<span style=color:#a6e22e>isAdminProfile</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Perform safe operation, e.g., database update</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>Sanitize the <code>username</code> field to prevent command injection:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>username.<span style=color:#a6e22e>matches</span>(<span style=color:#e6db74>&#34;^[a-zA-Z0-9]+$&#34;</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(<span style=color:#e6db74>&#34;Invalid username&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><strong>Configuration Fix</strong>:<ul><li>Configure the Java runtime to enable deserialization filters (Java 9+):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>java -Djdk.serialFilter<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;com.admin.security.source.User;!*&#34;</span>
</span></span></code></pre></div></li><li>Run the GlassFish server with minimal privileges (non-root user) to limit the impact of command execution.</li></ul></li></ul></li><li><strong>Additional Best Practice</strong>:<ul><li>Use JSON or other safer data formats instead of Java serialization for JWT payloads.</li><li>Regularly audit dependencies for known deserialization vulnerabilities (e.g., using tools like OWASP Dependency-Check).</li></ul></li></ul><hr><h3 id=6-insecure-jwt-secret-key-exposure-via-lfi>6. <strong>Insecure JWT Secret Key Exposure via LFI</strong><a href=#6-insecure-jwt-secret-key-exposure-via-lfi class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Gap Description</strong>: The Flask application&rsquo;s LFI vulnerability exposed the secret key used to sign JWTs in <code>app.py</code>. This allowed attackers to forge valid JWT tokens.</li><li><strong>Impact</strong>: Attackers can forge JWTs to impersonate users or manipulate payloads, enabling further exploits like deserialization attacks.</li><li><strong>Fix</strong>:<ul><li><strong>Source Code Fix</strong>:<ul><li>Store sensitive keys in environment variables or a secure configuration file outside the web root:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span>SECRET_KEY <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>getenv(<span style=color:#e6db74>&#39;JWT_SECRET_KEY&#39;</span>)
</span></span></code></pre></div></li><li>Ensure the secret key is cryptographically secure (e.g., generated with sufficient entropy):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> secrets
</span></span><span style=display:flex><span>SECRET_KEY <span style=color:#f92672>=</span> secrets<span style=color:#f92672>.</span>token_hex(<span style=color:#ae81ff>32</span>)
</span></span></code></pre></div></li></ul></li><li><strong>Configuration Fix</strong>:<ul><li>Restrict file system access to prevent LFI (see LFI fix above).</li><li>Store configuration files in a directory inaccessible to the web server (e.g., <code>/etc/flaskapp/config</code> with permissions <code>600</code> and owned by a non-web user).</li><li>Use a secrets management solution (e.g., HashiCorp Vault, AWS Secrets Manager) to manage and rotate keys securely.</li></ul></li></ul></li><li><strong>Additional Best Practice</strong>:<ul><li>Rotate JWT secret keys regularly and invalidate old tokens.</li><li>Implement token validation checks (e.g., expiration, audience) to limit the impact of forged tokens.</li></ul></li></ul><hr><h3 id=7-setuid-binary-vulnerability->7. <strong>SetUID Binary Vulnerability (<code>cmatch</code>)</strong><a href=#7-setuid-binary-vulnerability- class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Gap Description</strong>: The SetUID binary <code>/usr/bin/cmatch</code> (owned by user <code>john</code>) allows regex-based file content matching, enabling boolean-based exfiltration of sensitive files (e.g., <code>/home/john/.ssh/id_rsa</code>) one character at a time when run by a lower-privileged user.</li><li><strong>Impact</strong>: Attackers can extract sensitive data from files readable by the <code>john</code> user, such as SSH private keys.</li><li><strong>Fix</strong>:<ul><li><strong>Source Code Fix</strong>:<ul><li>Restrict <code>cmatch</code> to only process specific files or patterns:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strcmp</span>(filename, <span style=color:#e6db74>&#34;/var/log/allowed.log&#34;</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Access denied</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>Remove regex support if not needed, or sanitize regex patterns to prevent complex queries:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strstr</span>(pattern, <span style=color:#e6db74>&#34;[&#34;</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>strstr</span>(pattern, <span style=color:#e6db74>&#34;^&#34;</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Complex regex not allowed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><strong>Configuration Fix</strong>:<ul><li>Remove the SetUID bit from <code>cmatch</code> if not required:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>chmod u-s /usr/bin/cmatch
</span></span></code></pre></div></li><li>Restrict access to <code>cmatch</code> to specific users or groups:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>chown root:john /usr/bin/cmatch
</span></span><span style=display:flex><span>chmod <span style=color:#ae81ff>750</span> /usr/bin/cmatch
</span></span></code></pre></div></li><li>Use AppArmor or SELinux to confine <code>cmatch</code> to specific files and operations.</li></ul></li></ul></li><li><strong>Additional Best Practice</strong>:<ul><li>Audit all SetUID/SetGID binaries on the system (<code>find / -perm -4000</code>) and remove unnecessary ones.</li><li>Monitor execution of SetUID binaries using auditd or similar tools.</li></ul></li></ul><hr><h3 id=8-weak-ssh-key-passphrase>8. <strong>Weak SSH Key Passphrase</strong><a href=#8-weak-ssh-key-passphrase class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Gap Description</strong>: The SSH private key for user <code>john</code> was protected by a weak passphrase, crackable using <code>john</code> with a wordlist and system-derived passwords (e.g., Hibernate database password).</li><li><strong>Impact</strong>: Attackers can gain unauthorized access to the <code>john</code> account via SSH after extracting the key.</li><li><strong>Fix</strong>:<ul><li><strong>Configuration Fix</strong>:<ul><li>Enforce strong passphrase policies for SSH keys using tools like <code>ssh-keygen</code> with minimum length and complexity requirements.</li><li>Disable password-based SSH authentication in <code>/etc/ssh/sshd_config</code>:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>PasswordAuthentication no
</span></span></code></pre></div></li><li>Use a key management solution to generate and store strong passphrases securely.</li></ul></li><li><strong>Additional Best Practice</strong>:<ul><li>Regularly rotate SSH keys and passphrases.</li><li>Implement multi-factor authentication (MFA) for SSH access (e.g., using PAM modules or SSH key + TOTP).</li></ul></li></ul></li></ul><hr><h3 id=9-ecb-mode-encryption-in-flask-beta-application-port-8088>9. <strong>ECB Mode Encryption in Flask Beta Application (Port 8088)</strong><a href=#9-ecb-mode-encryption-in-flask-beta-application-port-8088 class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Gap Description</strong>: The Flask application on port 8088 uses ECB mode encryption for cookies in the format <code>username,secret,true/false</code>. ECB&rsquo;s lack of diffusion allows attackers to brute-force the secret one byte at a time by matching ciphertext blocks.</li><li><strong>Impact</strong>: Attackers can forge admin cookies (e.g., <code>admin,secret,true</code>) to gain unauthorized access to the <code>/admin</code> endpoint.</li><li><strong>Fix</strong>:<ul><li><strong>Source Code Fix</strong>:<ul><li>Replace ECB with a secure encryption mode like CBC or GCM, which provide diffusion and authentication:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> cryptography.hazmat.primitives.ciphers <span style=color:#f92672>import</span> Cipher, algorithms, modes
</span></span><span style=display:flex><span>key <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>urandom(<span style=color:#ae81ff>32</span>)
</span></span><span style=display:flex><span>iv <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>urandom(<span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>cipher <span style=color:#f92672>=</span> Cipher(algorithms<span style=color:#f92672>.</span>AES(key), modes<span style=color:#f92672>.</span>CBC(iv))
</span></span></code></pre></div></li><li>Use HMAC for cookie integrity instead of relying on encryption alone:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> hmac
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> hashlib
</span></span><span style=display:flex><span>cookie <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>username<span style=color:#e6db74>}</span><span style=color:#e6db74>,</span><span style=color:#e6db74>{</span>secret<span style=color:#e6db74>}</span><span style=color:#e6db74>,</span><span style=color:#e6db74>{</span>is_admin<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>mac <span style=color:#f92672>=</span> hmac<span style=color:#f92672>.</span>new(key, cookie<span style=color:#f92672>.</span>encode(), hashlib<span style=color:#f92672>.</span>sha256)<span style=color:#f92672>.</span>hexdigest()
</span></span><span style=display:flex><span>final_cookie <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>cookie<span style=color:#e6db74>}</span><span style=color:#e6db74>:</span><span style=color:#e6db74>{</span>mac<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div></li><li>Validate cookie format and content before processing:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> re<span style=color:#f92672>.</span><span style=color:#66d9ef>match</span>(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;^[a-zA-Z0-9]+,[a-zA-Z0-9]+,(true|false)$&#34;</span>, cookie):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Invalid cookie&#34;</span>, <span style=color:#ae81ff>403</span>
</span></span></code></pre></div></li></ul></li><li><strong>Configuration Fix</strong>:<ul><li>Ensure cryptographic keys are securely generated and stored (e.g., in environment variables or a secrets manager).</li><li>Rotate encryption keys regularly and invalidate old cookies.</li></ul></li></ul></li><li><strong>Additional Best Practice</strong>:<ul><li>Use established libraries like <code>itsdangerous</code> for secure cookie signing in Flask.</li><li>Test cryptographic implementations for vulnerabilities using tools like Cryptosense or manual audits.</li></ul></li></ul><hr><h3 id=10-lfi-in-flask-beta-application-port-8088-admin-endpoint>10. <strong>LFI in Flask Beta Application (Port 8088, Admin Endpoint)</strong><a href=#10-lfi-in-flask-beta-application-port-8088-admin-endpoint class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Gap Description</strong>: The <code>/admin</code> endpoint in the Flask beta application allows LFI when accessed with an admin cookie, enabling attackers to read sensitive files like <code>/root/.ssh/id_rsa</code>.</li><li><strong>Impact</strong>: Attackers can extract the root SSH private key, leading to full system compromise.</li><li><strong>Fix</strong>:<ul><li><strong>Source Code Fix</strong>:<ul><li>Implement strict file path validation (similar to the LFI fix for port 80):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>ALLOWED_FILES <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;auth.log&#39;</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>view_admin_log</span>(filename):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> filename <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> ALLOWED_FILES:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Invalid file&#34;</span>, <span style=color:#ae81ff>403</span>
</span></span><span style=display:flex><span>    safe_path <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(<span style=color:#e6db74>&#39;/var/log/app&#39;</span>, filename)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>realpath(safe_path)<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#39;/var/log/app&#39;</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Access denied&#34;</span>, <span style=color:#ae81ff>403</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Proceed with file reading</span>
</span></span></code></pre></div></li><li>Add authentication and authorization checks to ensure only legitimate admins can access the endpoint:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> session<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;is_admin&#39;</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> redirect(<span style=color:#e6db74>&#39;/login&#39;</span>, code<span style=color:#f92672>=</span><span style=color:#ae81ff>302</span>)
</span></span></code></pre></div></li></ul></li><li><strong>Configuration Fix</strong>:<ul><li>Restrict file system permissions for the Flask application user to prevent access to sensitive directories (e.g., <code>/root</code>).</li><li>Configure a reverse proxy (e.g., Nginx) to block requests with suspicious paths:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>location</span> <span style=color:#e6db74>/admin</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>if</span> <span style=color:#e6db74>(</span>$request_uri ~ <span style=color:#e6db74>&#34;\.\./&#34;)</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>return</span> <span style=color:#ae81ff>403</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li><li><strong>Additional Best Practice</strong>:<ul><li>Use a WAF to block directory traversal patterns.</li><li>Log and monitor file access attempts to detect unauthorized access.</li></ul></li></ul><hr><h3 id=11-outdated-software-python-2-glassfish-501>11. <strong>Outdated Software (Python 2, GlassFish 5.0.1)</strong><a href=#11-outdated-software-python-2-glassfish-501 class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Gap Description</strong>: The system runs Python 2 (end-of-life since 2020) on port 80 and Sun GlassFish 5.0.1 (~2017-2018) on port 8080, both outdated and potentially vulnerable to known exploits.</li><li><strong>Impact</strong>: Outdated software increases the attack surface, as unpatched vulnerabilities (e.g., CVEs in GlassFish) may exist.</li><li><strong>Fix</strong>:<ul><li><strong>Configuration Fix</strong>:<ul><li>Upgrade Python to a supported version (e.g., Python 3.10+):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>apt remove python2
</span></span><span style=display:flex><span>apt install python3
</span></span></code></pre></div></li><li>Upgrade GlassFish to a supported version (e.g., Eclipse GlassFish 7.x) or migrate to a modern alternative like Apache Tomcat:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>apt install tomcat9
</span></span></code></pre></div></li><li>Regularly apply security patches to all software components.</li></ul></li><li><strong>Additional Best Practice</strong>:<ul><li>Use a dependency management tool (e.g., Dependabot) to monitor and update software versions.</li><li>Scan for CVEs using tools like Nessus or OpenVAS.</li></ul></li></ul></li></ul><hr><h3 id=12-unnecessary-exposure-of-sensitive-files-war-file-source-code>12. <strong>Unnecessary Exposure of Sensitive Files (WAR File, Source Code)</strong><a href=#12-unnecessary-exposure-of-sensitive-files-war-file-source-code class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Gap Description</strong>: The <code>/backups</code> directory on port 8080 exposes Java source code (<code>User.java</code>, <code>Profile.java</code>, <code>UserProfileStorage.java</code>) and a WAR file (<code>internal_app.war</code>), accessible without authentication. These files contain sensitive information like application logic and database credentials.</li><li><strong>Impact</strong>: Attackers can analyze source code to identify vulnerabilities and extract credentials (e.g., Hibernate password).</li><li><strong>Fix</strong>:<ul><li><strong>Configuration Fix</strong>:<ul><li>Restrict access to the <code>/backups</code> directory using web server configuration:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;!-- GlassFish web.xml --&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;security-constraint&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;web-resource-collection&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;web-resource-name&gt;</span>Backups<span style=color:#f92672>&lt;/web-resource-name&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;url-pattern&gt;</span>/backups/*<span style=color:#f92672>&lt;/url-pattern&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/web-resource-collection&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;auth-constraint&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;role-name&gt;</span>admin<span style=color:#f92672>&lt;/role-name&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/auth-constraint&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/security-constraint&gt;</span>
</span></span></code></pre></div></li><li>Move sensitive files (e.g., source code, WAR files) outside the web root and restrict access:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mv /path/to/backups /secure/location
</span></span><span style=display:flex><span>chmod <span style=color:#ae81ff>700</span> /secure/location
</span></span></code></pre></div></li></ul></li><li><strong>Source Code Fix</strong>:<ul><li>Avoid storing sensitive files in publicly accessible directories. Use a build process to exclude source code and WAR files from deployment.</li></ul></li><li><strong>Additional Best Practice</strong>:<ul><li>Implement access logging and monitoring to detect unauthorized access to sensitive directories.</li><li>Use a CI/CD pipeline to ensure only compiled artifacts are deployed.</li></ul></li></ul></li></ul><hr><h3 id=13-weak-database-credentials-in-war-file>13. <strong>Weak Database Credentials in WAR File</strong><a href=#13-weak-database-credentials-in-war-file class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Gap Description</strong>: The <code>internal_app.war</code> file contains hardcoded Hibernate credentials (<code>hdb:q9...</code>), which were used to crack the SSH key passphrase due to password reuse.</li><li><strong>Impact</strong>: Attackers can access the database and extract sensitive data, and reused passwords enable further privilege escalation.</li><li><strong>Fix</strong>:<ul><li><strong>Source Code Fix</strong>:<ul><li>Remove hardcoded credentials from source code and WAR files. Use environment variables or a configuration file:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String dbPassword <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>getenv</span>(<span style=color:#e6db74>&#34;DB_PASSWORD&#34;</span>);
</span></span></code></pre></div></li></ul></li><li><strong>Configuration Fix</strong>:<ul><li>Store database credentials in a secure location (e.g., <code>/etc/app/db.conf</code> with <code>600</code> permissions).</li><li>Use a secrets management solution (e.g., HashiCorp Vault) to manage credentials.</li><li>Enforce strong, unique passwords for all accounts and services.</li></ul></li><li><strong>Additional Best Practice</strong>:<ul><li>Implement least privilege for database users (e.g., restrict <code>hdb</code> to specific tables).</li><li>Rotate credentials regularly and monitor for password reuse across services.</li></ul></li></ul></li></ul><hr><h3 id=14-unnecessary-open-ports-and-services>14. <strong>Unnecessary Open Ports and Services</strong><a href=#14-unnecessary-open-ports-and-services class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Gap Description</strong>: The system exposes multiple ports (22, 80, 8080, 8088, etc.) and services (SSH, Flask, GlassFish, Flask beta), some of which may not be necessary for the application&rsquo;s functionality.</li><li><strong>Impact</strong>: Unnecessary open ports increase the attack surface, providing more entry points for exploitation.</li><li><strong>Fix</strong>:<ul><li><strong>Configuration Fix</strong>:<ul><li>Disable unused services in <code>systemd</code>:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>systemctl disable flaskbeta
</span></span><span style=display:flex><span>systemctl stop flaskbeta
</span></span></code></pre></div></li><li>Configure the firewall to allow only necessary ports (e.g., 22, 80):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ufw allow <span style=color:#ae81ff>22</span>
</span></span><span style=display:flex><span>ufw allow <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>ufw deny <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>ufw deny <span style=color:#ae81ff>8088</span>
</span></span><span style=display:flex><span>ufw enable
</span></span></code></pre></div></li><li>Bind services to specific interfaces (e.g., <code>localhost</code> for internal services like Flask beta):<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># In /etc/systemd/system/flaskbeta.service</span>
</span></span><span style=display:flex><span>ExecStart<span style=color:#f92672>=</span>/usr/bin/python3 app.py --host<span style=color:#f92672>=</span>127.0.0.1 --port<span style=color:#f92672>=</span><span style=color:#ae81ff>8088</span>
</span></span></code></pre></div></li></ul></li><li><strong>Additional Best Practice</strong>:<ul><li>Conduct regular port scans to identify and close unnecessary open ports.</li><li>Use network segmentation to isolate internal services from external access.</li></ul></li></ul></li></ul><hr><h3 id=summary-of-fixes>Summary of Fixes<a href=#summary-of-fixes class=hanchor arialabel=Anchor>#</a></h3><ul><li><strong>Source Code Fixes</strong>: Address EAR, XSS, LFI, HQL injection, deserialization, JWT handling, SetUID binary logic, ECB encryption, and hardcoded credentials through proper input validation, secure coding practices, and removal of unsafe functionality.</li><li><strong>Configuration Fixes</strong>: Restrict file system and network access, enforce strong authentication, update outdated software, secure credentials, and limit service exposure.</li><li><strong>Best Practices</strong>: Implement CSP, WAF, secrets management, regular audits, and monitoring to enhance overall security.</li></ul><p>By applying these fixes, the identified vulnerabilities can be mitigated, significantly reducing the risk of exploitation and securing the system against similar attacks.</p></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>Â© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>